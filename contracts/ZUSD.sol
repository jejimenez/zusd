// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "./TokenReserve.sol";
import "hardhat/console.sol";


contract ZUSD is ERC20, Ownable, TokenReserve, KeeperCompatibleInterface {
    using Counters for Counters.Counter;

    uint256 public lastTimeStamp;
    uint256 public lastTimeStampIdUnblocked;
    bool pauseKeeper;

    struct BlockedData {
        address payable depositor;
        uint256 amount;
        uint256 timestamp;
    }

    Counters.Counter public tokenIdCounter;

    mapping(address => uint256) public mintTimestamp;
    mapping(uint256 => BlockedData) public blocked;
    //mapping(uint256 => ) public mintTimestamp;
    uint256 private interval;
    //blockedData[] private blocked;
    

    constructor(address _stableAddress) ERC20("Zulu USD", "ZUSD") TokenReserve(_stableAddress){
        lastTimeStamp = block.timestamp;
        lastTimeStampIdUnblocked = 0;
        interval = 5;
        //_mint(msg.sender, initialSupply);
    }

    function mint(uint amount) external {
        _mint(msg.sender, amount);
        uint mintTm = block.timestamp;
        pauseKeeper = false;
        uint256 tokenId = tokenIdCounter.current();
        tokenIdCounter.increment();
        //mintTimestamp[msg.sender] = block.timestamp;
        //blocked.push(blockedData(payable(msg.sender), amount, mintTimestamp[msg.sender]));
        blocked[tokenId] = BlockedData(payable(msg.sender), amount, mintTm);
    }


    function decimals() public pure override returns (uint8) {
        return 6;
    }

    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = !pauseKeeper && ((block.timestamp - lastTimeStamp) > interval);        
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval ) {
            unblockStableBatch();
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function unblockStableBatch() public onlyOwner{
        uint curTimestamp = block.timestamp;
        uint i = lastTimeStampIdUnblocked;
        for(i ; i < tokenIdCounter.current(); i++){
            if(curTimestamp - blocked[i].timestamp >= interval){
                address addr   = blocked[i].depositor;
                uint256 amount = blocked[i].amount;
                unstakePartialTokens(addr, amount);
                delete blocked[i];
            }
        }
        lastTimeStampIdUnblocked = i-1;
        lastTimeStamp = curTimestamp;            
    }

    function setPauseKeeper(bool _pauseKeeper) public onlyOwner{
        pauseKeeper = _pauseKeeper;
    }

    function getBlocked(uint i) view public onlyOwner returns(BlockedData memory){
        return blocked[i];
    }
}